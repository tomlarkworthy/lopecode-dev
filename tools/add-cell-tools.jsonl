{"cmd": "load", "notebook": "lopecode/lopebooks/notebooks/@tomlarkworthy_opencode-agent.html", "hash": "view=R100(S50(@tomlarkworthy/reactive-reflective-testing),S50(@tomlarkworthy/exporter-2))"}

{"cmd": "define-variable", "name": "readCellTool", "definition": "(defineTool) => defineTool({ id: 'read_cell', description: 'Read information about a notebook cell/variable including its current value and error state.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to read' } }, required: ['name'] }, execute: async (args, ctx) => { const { name } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Read cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let found = null; for (const v of runtime._variables) { if (v._name === name) { found = v; break; } } if (!found) return { title: 'Read cell: ' + name, output: 'Error: Cell not found: ' + name, metadata: { error: true, notFound: true } }; const serialize = (value, maxLen = 2000) => { if (value === undefined) return 'undefined'; if (value === null) return 'null'; if (value instanceof Error) return 'Error: ' + value.message; if (typeof value === 'function') return value.toString().slice(0, maxLen); if (typeof value === 'object') { try { return JSON.stringify(value, null, 2).slice(0, maxLen); } catch { return String(value); } } return String(value).slice(0, maxLen); }; const result = { name: found._name, hasValue: found._value !== undefined, hasError: found._error !== undefined, value: serialize(found._value), error: found._error?.message, reachable: found._reachable, inputs: found._inputs?.map(i => i._name).filter(Boolean) || [] }; return { title: 'Read cell: ' + name, output: JSON.stringify(result, null, 2), metadata: result }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "listCellsTool", "definition": "(defineTool) => defineTool({ id: 'list_cells', description: 'List all cells/variables in the notebook runtime with their names and states.', parameters: { type: 'object', properties: { filter: { type: 'string', description: 'Optional filter string to match cell names' }, module: { type: 'string', description: 'Optional module name to filter by' } }, required: [] }, execute: async (args, ctx) => { const { filter, module } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'List cells', output: 'Error: Observable runtime not found', metadata: { error: true } }; const moduleNames = new Map(); for (const v of runtime._variables) { if (v._module && !moduleNames.has(v._module)) { const modName = v._module._name || (v._name?.startsWith('module ') ? v._name : null); if (modName) moduleNames.set(v._module, modName); } } const variables = []; for (const v of runtime._variables) { if (!v._name) continue; const moduleName = moduleNames.get(v._module) || 'main'; if (filter && !v._name.includes(filter)) continue; if (module && moduleName !== module && !moduleName.includes(module)) continue; variables.push({ name: v._name, module: moduleName, hasValue: v._value !== undefined, hasError: v._error !== undefined, reachable: v._reachable }); } variables.sort((a, b) => { const modCmp = a.module.localeCompare(b.module); if (modCmp !== 0) return modCmp; return a.name.localeCompare(b.name); }); return { title: 'List cells (' + variables.length + ' found)', output: variables.map(v => v.module + '#' + v.name + ' [' + (v.hasValue ? 'value' : v.hasError ? 'error' : 'pending') + ']').join('\\n'), metadata: { count: variables.length, variables } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "defineCellTool", "definition": "(defineTool) => defineTool({ id: 'define_cell', description: 'Define or redefine a notebook cell/variable with new code. The definition should be a JavaScript function string.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to define' }, definition: { type: 'string', description: 'JavaScript function definition, e.g., \"() => 42\" or \"(x, y) => x + y\"' }, inputs: { type: 'array', description: 'Array of input variable names this cell depends on' }, module: { type: 'string', description: 'Optional module name to define the cell in' } }, required: ['name', 'definition'] }, execute: async (args, ctx) => { const { name, definition, inputs = [], module: moduleName } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Define cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let targetModule = null; if (!moduleName) { for (const v of runtime._variables) { if (v._module) { targetModule = v._module; break; } } } else { for (const v of runtime._variables) { if (v._module?._name === moduleName) { targetModule = v._module; break; } if (v._name === 'module ' + moduleName) { targetModule = v._module; break; } } } if (!targetModule) return { title: 'Define cell: ' + name, output: 'Error: Module not found: ' + (moduleName || 'main'), metadata: { error: true } }; let existingVar = null; for (const v of runtime._variables) { if (v._name === name && v._module === targetModule) { existingVar = v; break; } } let fn; try { eval('fn = ' + definition); if (typeof fn !== 'function') return { title: 'Define cell: ' + name, output: 'Error: Definition must evaluate to a function', metadata: { error: true } }; } catch (e) { return { title: 'Define cell: ' + name, output: 'Error: Failed to parse definition: ' + e.message, metadata: { error: true } }; } try { if (existingVar) { existingVar.define(name, inputs, fn); } else { const newVar = targetModule.variable({}); newVar.define(name, inputs, fn); } const actualRuntime = targetModule._runtime; if (actualRuntime?._computeNow) actualRuntime._computeNow(); return { title: 'Define cell: ' + name, output: 'Successfully ' + (existingVar ? 'redefined' : 'defined') + ' cell \"' + name + '\"', metadata: { name, module: targetModule._name || 'main', redefined: !!existingVar, inputs } }; } catch (e) { return { title: 'Define cell: ' + name, output: 'Error: Failed to define variable: ' + e.message, metadata: { error: true } }; } } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "deleteCellTool", "definition": "(defineTool) => defineTool({ id: 'delete_cell', description: 'Delete a cell/variable from the notebook runtime.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to delete' }, module: { type: 'string', description: 'Optional module name containing the cell' } }, required: ['name'] }, execute: async (args, ctx) => { const { name, module: moduleName } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Delete cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let targetModule = null; if (!moduleName) { for (const v of runtime._variables) { if (v._module) { targetModule = v._module; break; } } } else { for (const v of runtime._variables) { if (v._module?._name === moduleName) { targetModule = v._module; break; } if (v._name === 'module ' + moduleName) { targetModule = v._module; break; } } } if (!targetModule) return { title: 'Delete cell: ' + name, output: 'Error: Module not found: ' + (moduleName || 'main'), metadata: { error: true } }; for (const v of runtime._variables) { if (v._name === name && v._module === targetModule) { v.delete(); return { title: 'Delete cell: ' + name, output: 'Successfully deleted cell \"' + name + '\"', metadata: { name, module: targetModule._name || 'main' } }; } } return { title: 'Delete cell: ' + name, output: 'Error: Variable not found: ' + name + ' in module ' + (moduleName || 'main'), metadata: { error: true, notFound: true } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "getCellValueTool", "definition": "(defineTool) => defineTool({ id: 'get_cell_value', description: 'Get the computed value of a cell, forcing computation if needed.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable' }, timeout: { type: 'number', description: 'Timeout in milliseconds (default 5000)' } }, required: ['name'] }, execute: async (args, ctx) => { const { name, timeout = 5000 } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Get value: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let found = null; for (const v of runtime._variables) { if (v._name === name) { found = v; break; } } if (!found) return { title: 'Get value: ' + name, output: 'Error: Cell not found: ' + name, metadata: { error: true, notFound: true } }; let actualRuntime = null; for (const v of runtime._variables) { if (v._module?._runtime?._computeNow) { actualRuntime = v._module._runtime; break; } } if (!found._reachable && actualRuntime) { found._reachable = true; actualRuntime._dirty.add(found); actualRuntime._computeNow(); } return new Promise((resolve) => { const timeoutId = setTimeout(() => { resolve({ title: 'Get value: ' + name, output: 'Error: Timeout waiting for cell value', metadata: { error: true, timeout: true } }); }, timeout); const serialize = (value, maxLen = 2000) => { if (value === undefined) return 'undefined'; if (value === null) return 'null'; if (typeof value === 'function') return value.toString().slice(0, maxLen); if (typeof value === 'object') { try { return JSON.stringify(value, null, 2).slice(0, maxLen); } catch { return String(value); } } return String(value).slice(0, maxLen); }; if (found._value !== undefined || found._error !== undefined) { clearTimeout(timeoutId); if (found._error) { resolve({ title: 'Get value: ' + name, output: 'Error: ' + found._error.message, metadata: { error: true, cellError: found._error.message } }); } else { resolve({ title: 'Get value: ' + name, output: serialize(found._value), metadata: { value: found._value } }); } return; } const oldObserver = found._observer; found._observer = { fulfilled: (value) => { clearTimeout(timeoutId); found._observer = oldObserver; resolve({ title: 'Get value: ' + name, output: serialize(value), metadata: { value } }); if (oldObserver?.fulfilled) oldObserver.fulfilled(value); }, rejected: (error) => { clearTimeout(timeoutId); found._observer = oldObserver; resolve({ title: 'Get value: ' + name, output: 'Error: ' + (error?.message || String(error)), metadata: { error: true, cellError: error?.message } }); if (oldObserver?.rejected) oldObserver.rejected(error); }, pending: () => { if (oldObserver?.pending) oldObserver.pending(); } }; if (actualRuntime?._computeNow) actualRuntime._computeNow(); }); } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "cellTools", "definition": "(readCellTool, listCellsTool, defineCellTool, deleteCellTool, getCellValueTool) => [readCellTool, listCellsTool, defineCellTool, deleteCellTool, getCellValueTool]", "inputs": ["readCellTool", "listCellsTool", "defineCellTool", "deleteCellTool", "getCellValueTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "test_opencode_cellToolsDefined", "definition": "(cellTools) => { if (!Array.isArray(cellTools) || cellTools.length !== 5) throw new Error('Wrong number of tools: ' + cellTools.length); const ids = cellTools.map(t => t.id); if (!ids.includes('read_cell')) throw new Error('Missing read_cell'); if (!ids.includes('list_cells')) throw new Error('Missing list_cells'); if (!ids.includes('define_cell')) throw new Error('Missing define_cell'); if (!ids.includes('delete_cell')) throw new Error('Missing delete_cell'); if (!ids.includes('get_cell_value')) throw new Error('Missing get_cell_value'); return 'pass'; }", "inputs": ["cellTools"], "module": "@tomlarkworthy/tests"}

{"cmd": "run-tests", "filter": "test_opencode", "timeout": 25000}
{"cmd": "quit"}
