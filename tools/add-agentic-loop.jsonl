{"cmd": "load", "notebook": "lopecode/lopebooks/notebooks/@tomlarkworthy_opencode-agent.html", "hash": "view=R100(S50(@tomlarkworthy/reactive-reflective-testing),S50(@tomlarkworthy/exporter-2))"}

{"cmd": "define-variable", "name": "completeAssistantMessage", "definition": "() => ((message, { finish, tokens, cost }) => ({ ...message, time: { ...message.time, completed: Date.now() }, finish, tokens: tokens || message.tokens, cost: cost ?? message.cost }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createStepStartPart", "definition": "(generateId) => (({ sessionId, messageId }) => ({ id: generateId(), sessionId, messageId, type: 'step-start' }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createStepFinishPart", "definition": "(generateId) => (({ sessionId, messageId, reason, tokens, cost }) => ({ id: generateId(), sessionId, messageId, type: 'step-finish', reason, cost, tokens }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createMessageWithParts", "definition": "() => ((info, parts = []) => ({ info, parts }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "addPart", "definition": "() => ((messageWithParts, part) => ({ ...messageWithParts, parts: [...messageWithParts.parts, part] }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "updatePart", "definition": "() => ((messageWithParts, partId, updates) => ({ ...messageWithParts, parts: messageWithParts.parts.map(p => p.id === partId ? { ...p, ...updates } : p) }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createConversation", "definition": "(generateId) => (({ id } = {}) => ({ id: id || generateId(), messages: [], created: Date.now() }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "addMessage", "definition": "() => ((conversation, messageWithParts) => ({ ...conversation, messages: [...conversation.messages, messageWithParts] }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "isToolPart", "definition": "() => (part => part?.type === 'tool')", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "updateToolPart", "definition": "(isToolPart) => ((message, callId, updates) => ({ ...message, parts: message.parts.map(p => isToolPart(p) && p.callId === callId ? { ...p, ...updates } : p) }))", "inputs": ["isToolPart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "conversationToMessages", "definition": "() => (conversation => conversation.messages.map(msg => { const role = msg.info.role; if (role === 'user') { const textParts = msg.parts.filter(p => p.type === 'text'); return { role: 'user', content: textParts.map(p => p.text).join('\\n') }; } else if (role === 'assistant') { return { role: 'assistant', parts: msg.parts }; } return { role, content: '' }; }))", "inputs": [], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "createLoop", "definition": "(anthropicProvider, streamAnthropic, createConversation, createUserMessage, createAssistantMessage, completeAssistantMessage, createTextPart, createReasoningPart, createToolPart, createStepStartPart, createStepFinishPart, createMessageWithParts, addPart, updatePart, addMessage, toolStatePending, toolStateRunning, toolStateCompleted, toolStateError, updateToolPart, conversationToMessages, createToolContext) => ((config) => { const { providerId, modelId, apiKey, systemPrompt, registry, maxSteps = 10, settings = {} } = config; const provider = anthropicProvider({ apiKey }); const tools = registry.toAnthropicFormat(); let conversation = createConversation(); let abortController = null; let isRunning = false; async function run(userPrompt, callbacks = {}) { if (isRunning) throw new Error('Loop is already running'); isRunning = true; abortController = new AbortController(); try { const userMessage = createUserMessage({ sessionId: conversation.id, agent: 'user', providerId, modelId, system: systemPrompt }); const userWithParts = createMessageWithParts(userMessage, [createTextPart({ sessionId: conversation.id, messageId: userMessage.id, text: userPrompt })]); conversation = addMessage(conversation, userWithParts); let step = 0; while (step < maxSteps) { if (abortController.signal.aborted) break; callbacks.onStepStart?.(step); const assistantMessage = createAssistantMessage({ sessionId: conversation.id, parentId: userMessage.id, agent: 'assistant', providerId, modelId }); let currentMessage = createMessageWithParts(assistantMessage, [createStepStartPart({ sessionId: conversation.id, messageId: assistantMessage.id })]); let currentText = ''; let currentTextPartId = null; const pendingToolCalls = new Map(); const result = await streamAnthropic({ provider, model: modelId, messages: conversationToMessages(conversation), systemPrompt, tools, signal: abortController.signal, settings, callbacks: { onText: (chunk) => { currentText += chunk; if (!currentTextPartId) { const textPart = createTextPart({ sessionId: conversation.id, messageId: assistantMessage.id, text: currentText }); currentTextPartId = textPart.id; currentMessage = addPart(currentMessage, textPart); } else { currentMessage = updatePart(currentMessage, currentTextPartId, { text: currentText }); } callbacks.onText?.(chunk); callbacks.onMessage?.(currentMessage); }, onToolCall: (callId, toolName) => { const toolPart = createToolPart({ sessionId: conversation.id, messageId: assistantMessage.id, callId, tool: toolName, state: toolStatePending({}, '') }); pendingToolCalls.set(callId, { toolName, args: '' }); currentMessage = addPart(currentMessage, toolPart); callbacks.onMessage?.(currentMessage); }, onToolCallDelta: (callId, chunk) => { const tc = pendingToolCalls.get(callId); if (tc) tc.args += chunk; }, onError: (error) => callbacks.onError?.(error) } }); let hasToolCalls = false; for (const [callId, tc] of pendingToolCalls) { hasToolCalls = true; let input = {}; try { input = JSON.parse(tc.args); } catch {} const startTime = Date.now(); currentMessage = updateToolPart(currentMessage, callId, { state: toolStateRunning(input, 'Running ' + tc.toolName) }); callbacks.onToolStart?.(callId, tc.toolName, input); const ctx = createToolContext({ sessionId: conversation.id, messageId: assistantMessage.id, agent: 'assistant', callId, abort: abortController.signal, runtime: typeof window !== 'undefined' ? window.__ojs_runtime : null }); const toolResult = await registry.execute(tc.toolName, input, ctx); if (toolResult.metadata?.error) { currentMessage = updateToolPart(currentMessage, callId, { state: toolStateError({ input, error: toolResult.output, startTime }) }); } else { currentMessage = updateToolPart(currentMessage, callId, { state: toolStateCompleted({ input, output: toolResult.output, title: toolResult.title, metadata: toolResult.metadata, startTime }) }); } callbacks.onToolFinish?.(callId, tc.toolName, toolResult); callbacks.onMessage?.(currentMessage); } const stepFinishPart = createStepFinishPart({ sessionId: conversation.id, messageId: assistantMessage.id, reason: result.finishReason || 'unknown', tokens: result.usage || { input: 0, output: 0, reasoning: 0, cache: { read: 0, write: 0 } }, cost: 0 }); currentMessage = addPart(currentMessage, stepFinishPart); currentMessage = { ...currentMessage, info: completeAssistantMessage(currentMessage.info, { finish: result.finishReason, tokens: result.usage, cost: 0 }) }; conversation = addMessage(conversation, currentMessage); callbacks.onStepFinish?.(step, currentMessage); const shouldContinue = hasToolCalls && result.finishReason !== 'end_turn'; if (!shouldContinue) break; step++; } callbacks.onFinish?.(conversation); return conversation; } finally { isRunning = false; abortController = null; } } function cancel() { if (abortController) abortController.abort(); } function getConversation() { return conversation; } function reset() { if (isRunning) throw new Error('Cannot reset while running'); conversation = createConversation(); } function running() { return isRunning; } return { run, cancel, getConversation, reset, running }; })", "inputs": ["anthropicProvider", "streamAnthropic", "createConversation", "createUserMessage", "createAssistantMessage", "completeAssistantMessage", "createTextPart", "createReasoningPart", "createToolPart", "createStepStartPart", "createStepFinishPart", "createMessageWithParts", "addPart", "updatePart", "addMessage", "toolStatePending", "toolStateRunning", "toolStateCompleted", "toolStateError", "updateToolPart", "conversationToMessages", "createToolContext"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "test_opencode_completeAssistantMessage", "definition": "(completeAssistantMessage) => { const msg = { time: { created: 1000 }, tokens: {}, cost: 0 }; const completed = completeAssistantMessage(msg, { finish: 'end_turn', tokens: { input: 10 }, cost: 0.01 }); if (!completed.time.completed || completed.finish !== 'end_turn') throw new Error('Failed'); return 'pass'; }", "inputs": ["completeAssistantMessage"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createMessageWithParts", "definition": "(createMessageWithParts, addPart, updatePart) => { const msg = createMessageWithParts({ id: 'm1', role: 'assistant' }, []); if (msg.parts.length !== 0) throw new Error('Initial parts not empty'); const withPart = addPart(msg, { id: 'p1', type: 'text', text: 'hello' }); if (withPart.parts.length !== 1) throw new Error('Part not added'); const updated = updatePart(withPart, 'p1', { text: 'updated' }); if (updated.parts[0].text !== 'updated') throw new Error('Update failed'); return 'pass'; }", "inputs": ["createMessageWithParts", "addPart", "updatePart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createConversation", "definition": "(createConversation, addMessage, createMessageWithParts) => { const conv = createConversation(); if (!conv.id || conv.messages.length !== 0) throw new Error('Bad initial state'); const msg = createMessageWithParts({ id: 'm1', role: 'user' }, []); const updated = addMessage(conv, msg); if (updated.messages.length !== 1) throw new Error('Message not added'); return 'pass'; }", "inputs": ["createConversation", "addMessage", "createMessageWithParts"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createLoop", "definition": "(createLoop, createToolRegistry, defineTool) => { const registry = createToolRegistry(); registry.register(defineTool({ id: 'test', description: 'test', parameters: { type: 'object', properties: {} }, execute: async () => ({ title: 'Test', output: 'done', metadata: {} }) })); const loop = createLoop({ providerId: 'anthropic', modelId: 'claude-sonnet-4-20250514', apiKey: 'test-key', registry }); if (typeof loop.run !== 'function') throw new Error('run not a function'); if (typeof loop.cancel !== 'function') throw new Error('cancel not a function'); if (typeof loop.getConversation !== 'function') throw new Error('getConversation not a function'); return 'pass'; }", "inputs": ["createLoop", "createToolRegistry", "defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "run-tests", "filter": "test_opencode", "timeout": 20000}
{"cmd": "quit"}
