{"cmd": "load", "notebook": "lopecode/lopebooks/notebooks/@tomlarkworthy_opencode-agent.html", "hash": "view=R100(S50(@tomlarkworthy/reactive-reflective-testing),S50(@tomlarkworthy/exporter-2))"}
{"cmd": "define-variable", "name": "createTextPart", "definition": "(generateId) => (({ sessionId, messageId, text, synthetic = false }) => ({ id: generateId(), sessionId, messageId, type: 'text', text, synthetic, time: { start: Date.now(), end: null } }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createReasoningPart", "definition": "(generateId) => (({ sessionId, messageId, text }) => ({ id: generateId(), sessionId, messageId, type: 'reasoning', text, time: { start: Date.now(), end: null } }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStatePending", "definition": "() => ((input, raw = '') => ({ status: 'pending', input, raw }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateRunning", "definition": "() => ((input, title = null) => ({ status: 'running', input, title, metadata: {}, time: { start: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateCompleted", "definition": "() => (({ input, output, title, metadata = {}, startTime }) => ({ status: 'completed', input, output, title, metadata, time: { start: startTime, end: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateError", "definition": "() => (({ input, error, startTime }) => ({ status: 'error', input, error, metadata: {}, time: { start: startTime, end: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolPart", "definition": "(generateId) => (({ sessionId, messageId, callId, tool, state }) => ({ id: generateId(), sessionId, messageId, type: 'tool', callId, tool, state, metadata: {} }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "anthropicProvider", "definition": "() => (({ apiKey, baseUrl = 'https://api.anthropic.com/v1', version = '2023-06-01' }) => ({ id: 'anthropic', baseUrl, headers: () => ({ 'x-api-key': apiKey, 'anthropic-version': version, 'anthropic-dangerous-direct-browser-access': 'true', 'Content-Type': 'application/json' }), messagesEndpoint: baseUrl + '/messages' }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "parseSSEStream", "definition": "() => (async (stream, onEvent, signal) => { const reader = stream.getReader(); const decoder = new TextDecoder(); let buffer = ''; try { while (true) { if (signal?.aborted) break; const { done, value } = await reader.read(); if (done) break; buffer += decoder.decode(value, { stream: true }); const lines = buffer.split('\\n'); buffer = lines.pop() || ''; for (const line of lines) { if (line.startsWith('data: ')) { const data = line.slice(6); if (data === '[DONE]') return; try { onEvent(JSON.parse(data)); } catch {} } } } } finally { reader.releaseLock(); } })", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "streamAnthropic", "definition": "(parseSSEStream) => (async ({ provider, model, messages, systemPrompt, tools, callbacks, signal, settings = {} }) => { const body = { model, messages, max_tokens: settings.max_tokens || 4096, stream: true, ...settings }; if (systemPrompt) body.system = systemPrompt; if (tools && tools.length > 0) body.tools = tools; const response = await fetch(provider.messagesEndpoint, { method: 'POST', headers: provider.headers(), body: JSON.stringify(body), signal }); if (!response.ok) { const error = await response.text(); callbacks.onError?.(new Error('Anthropic API error: ' + response.status + ' - ' + error)); throw new Error('Anthropic API error: ' + response.status); } let currentToolUse = null; let stopReason = null; let usage = null; await parseSSEStream(response.body, (event) => { if (event.type === 'message_start') usage = event.message?.usage; if (event.type === 'content_block_start') { const block = event.content_block; if (block?.type === 'tool_use') { currentToolUse = { id: block.id, name: block.name, input: '' }; callbacks.onToolCall?.(block.id, block.name); } } if (event.type === 'content_block_delta') { const delta = event.delta; if (delta?.type === 'text_delta') callbacks.onText?.(delta.text); else if (delta?.type === 'thinking_delta') callbacks.onReasoning?.(delta.thinking); else if (delta?.type === 'input_json_delta' && currentToolUse) { currentToolUse.input += delta.partial_json; callbacks.onToolCallDelta?.(currentToolUse.id, delta.partial_json); } } if (event.type === 'content_block_stop') currentToolUse = null; if (event.type === 'message_delta') { stopReason = event.delta?.stop_reason; if (event.usage) usage = { ...usage, ...event.usage }; } }, signal); callbacks.onFinish?.({ finishReason: stopReason, usage }); return { finishReason: stopReason, usage }; })", "inputs": ["parseSSEStream"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createTextPart", "definition": "(createTextPart) => { const part = createTextPart({ sessionId: 's1', messageId: 'm1', text: 'Hello' }); if (part.type !== 'text' || part.text !== 'Hello' || !part.id) throw new Error('Failed'); return 'pass'; }", "inputs": ["createTextPart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_toolStates", "definition": "(toolStatePending, toolStateRunning, toolStateCompleted, toolStateError) => { const p = toolStatePending({ foo: 'bar' }); if (p.status !== 'pending') throw new Error('Pending failed'); const r = toolStateRunning({ foo: 'bar' }, 'title'); if (r.status !== 'running' || r.title !== 'title') throw new Error('Running failed'); const c = toolStateCompleted({ input: {}, output: 'out', title: 't', startTime: Date.now() }); if (c.status !== 'completed') throw new Error('Completed failed'); const e = toolStateError({ input: {}, error: 'err', startTime: Date.now() }); if (e.status !== 'error') throw new Error('Error failed'); return 'pass'; }", "inputs": ["toolStatePending", "toolStateRunning", "toolStateCompleted", "toolStateError"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolPart", "definition": "(createToolPart, toolStatePending) => { const part = createToolPart({ sessionId: 's1', messageId: 'm1', callId: 'c1', tool: 'echo', state: toolStatePending({ msg: 'hi' }) }); if (part.type !== 'tool' || part.tool !== 'echo' || part.state.status !== 'pending') throw new Error('Failed'); return 'pass'; }", "inputs": ["createToolPart", "toolStatePending"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_anthropicProvider", "definition": "(anthropicProvider) => { const provider = anthropicProvider({ apiKey: 'test-key' }); if (provider.id !== 'anthropic') throw new Error('Wrong id'); if (!provider.messagesEndpoint.includes('anthropic.com')) throw new Error('Wrong endpoint'); const headers = provider.headers(); if (headers['x-api-key'] !== 'test-key') throw new Error('Wrong api key header'); return 'pass'; }", "inputs": ["anthropicProvider"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_parseSSEStream", "definition": "(parseSSEStream) => { const events = []; const mockStream = { getReader: () => { let done = false; return { read: async () => { if (done) return { done: true }; done = true; return { done: false, value: new TextEncoder().encode('data: {\"type\":\"test\"}\\n\\n') }; }, releaseLock: () => {} }; } }; return parseSSEStream(mockStream, (e) => events.push(e)).then(() => { if (events.length !== 1 || events[0].type !== 'test') throw new Error('Parse failed: ' + JSON.stringify(events)); return 'pass'; }); }", "inputs": ["parseSSEStream"], "module": "@tomlarkworthy/tests"}
{"cmd": "run-tests", "filter": "test_opencode", "timeout": 20000}
{"cmd": "quit"}
