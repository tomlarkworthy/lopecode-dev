{"cmd": "load", "notebook": "lopecode/lopebooks/notebooks/@tomlarkworthy_opencode-agent.html", "hash": "view=R100(S50(@tomlarkworthy/reactive-reflective-testing),S50(@tomlarkworthy/exporter-2))"}

{"cmd": "define-variable", "name": "generateId", "definition": "() => (() => crypto.randomUUID())", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createUserMessage", "definition": "(generateId) => ({ sessionId, agent, providerId, modelId, system, tools }) => ({ id: generateId(), sessionId, role: 'user', time: { created: Date.now() }, agent, model: { providerId, modelId }, system, tools })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createAssistantMessage", "definition": "(generateId) => ({ sessionId, parentId, agent, providerId, modelId }) => ({ id: generateId(), sessionId, role: 'assistant', time: { created: Date.now(), completed: null }, parentId, agent, providerId, modelId, error: null, cost: 0, tokens: { input: 0, output: 0, reasoning: 0, cache: { read: 0, write: 0 } }, finish: null })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_generateId", "definition": "(generateId) => { const id = generateId(); if (typeof id !== 'string' || id.length < 30) throw new Error('bad id: ' + typeof id); return 'pass'; }", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createUserMessage", "definition": "(createUserMessage) => { const msg = createUserMessage({ sessionId: 'test', agent: 'user', providerId: 'anthropic', modelId: 'claude' }); if (!msg.id || msg.role !== 'user') throw new Error('failed: ' + JSON.stringify(msg)); return 'pass'; }", "inputs": ["createUserMessage"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createAssistantMessage", "definition": "(createAssistantMessage) => { const msg = createAssistantMessage({ sessionId: 'test', parentId: 'p1', agent: 'assistant', providerId: 'anthropic', modelId: 'claude' }); if (!msg.id || msg.role !== 'assistant') throw new Error('failed'); return 'pass'; }", "inputs": ["createAssistantMessage"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "validateParameters", "definition": "() => { const validate = (schema, value) => { const errors = []; if (schema.type === 'object') { if (typeof value !== 'object' || value === null) { errors.push('Expected object'); return { valid: false, errors }; } if (schema.required) { for (const field of schema.required) { if (!(field in value)) errors.push('Missing required field: ' + field); } } if (schema.properties) { for (const [key, propSchema] of Object.entries(schema.properties)) { if (key in value) { const r = validate(propSchema, value[key]); if (!r.valid) errors.push(...r.errors.map(e => key + ': ' + e)); } } } } else if (schema.type === 'string') { if (typeof value !== 'string') errors.push('Expected string, got ' + typeof value); } else if (schema.type === 'number' || schema.type === 'integer') { if (typeof value !== 'number') errors.push('Expected number, got ' + typeof value); } else if (schema.type === 'boolean') { if (typeof value !== 'boolean') errors.push('Expected boolean, got ' + typeof value); } else if (schema.type === 'array') { if (!Array.isArray(value)) errors.push('Expected array, got ' + typeof value); else if (schema.items) value.forEach((item, i) => { const r = validate(schema.items, item); if (!r.valid) errors.push(...r.errors.map(e => '[' + i + ']: ' + e)); }); } return { valid: errors.length === 0, errors }; }; return validate; }", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "defineTool", "definition": "(generateId) => (({ id, description, parameters, execute }) => { if (!id || typeof id !== 'string') throw new Error('Tool must have a string id'); if (!description || typeof description !== 'string') throw new Error('Tool must have a string description'); if (!parameters || typeof parameters !== 'object') throw new Error('Tool must have a parameters object'); if (!execute || typeof execute !== 'function') throw new Error('Tool must have an execute function'); return { id, description, parameters, execute: async (args, ctx) => { try { if (ctx.abort?.aborted) return { title: id + ' aborted', output: 'Execution was aborted', metadata: { aborted: true } }; const result = await execute(args, ctx); return { title: result.title || id + ' completed', output: typeof result.output === 'string' ? result.output : JSON.stringify(result.output), metadata: { ...ctx.getMetadata?.() || {}, ...result.metadata } }; } catch (error) { return { title: id + ' failed', output: 'Error: ' + error.message, metadata: { error: true, errorMessage: error.message } }; } } }; })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolContext", "definition": "(generateId) => (({ sessionId, messageId, agent, callId, abort, runtime }) => { let currentMetadata = {}; return { sessionId, messageId, agent, callId: callId || generateId(), abort: abort || new AbortController().signal, runtime: runtime || (typeof window !== 'undefined' ? window.__ojs_runtime : null), metadata(update) { currentMetadata = { ...currentMetadata, ...update }; }, getMetadata() { return currentMetadata; } }; })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolRegistry", "definition": "(validateParameters) => (() => { const tools = new Map(); return { register(tool) { if (tools.has(tool.id)) console.warn('Tool ' + tool.id + ' already registered, replacing'); tools.set(tool.id, tool); }, unregister(id) { return tools.delete(id); }, get(id) { return tools.get(id); }, has(id) { return tools.has(id); }, ids() { return [...tools.keys()]; }, all() { return [...tools.values()]; }, toAnthropicFormat() { return this.all().map(t => ({ name: t.id, description: t.description, input_schema: t.parameters })); }, async execute(id, args, ctx) { const tool = tools.get(id); if (!tool) return { title: 'Tool not found', output: 'Unknown tool: ' + id, metadata: { error: true } }; const validation = validateParameters(tool.parameters, args); if (!validation.valid) return { title: 'Invalid parameters', output: 'Parameter validation failed:\\n' + validation.errors.join('\\n'), metadata: { error: true, validationErrors: validation.errors } }; return tool.execute(args, ctx); } }; })", "inputs": ["validateParameters"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_validateParameters", "definition": "(validateParameters) => { const schema = { type: 'object', required: ['name'], properties: { name: { type: 'string' }, count: { type: 'number' } } }; const r1 = validateParameters(schema, { name: 'test', count: 5 }); if (!r1.valid) throw new Error('Valid input failed: ' + r1.errors.join(', ')); const r2 = validateParameters(schema, { count: 5 }); if (r2.valid || !r2.errors.includes('Missing required field: name')) throw new Error('Missing required not detected'); const r3 = validateParameters(schema, { name: 123 }); if (r3.valid || !r3.errors.some(e => e.includes('Expected string'))) throw new Error('Wrong type not detected'); return 'pass'; }", "inputs": ["validateParameters"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_defineTool", "definition": "(defineTool) => { const tool = defineTool({ id: 'test_tool', description: 'A test tool', parameters: { type: 'object', properties: {} }, execute: async (args) => ({ title: 'Test', output: 'result', metadata: {} }) }); if (tool.id !== 'test_tool') throw new Error('Wrong id'); if (typeof tool.execute !== 'function') throw new Error('Execute not a function'); return 'pass'; }", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolContext", "definition": "(createToolContext) => { const ctx = createToolContext({ sessionId: 's1', messageId: 'm1', agent: 'test' }); if (ctx.sessionId !== 's1') throw new Error('Wrong sessionId'); if (!ctx.callId) throw new Error('No callId'); ctx.metadata({ foo: 'bar' }); if (ctx.getMetadata().foo !== 'bar') throw new Error('Metadata not working'); return 'pass'; }", "inputs": ["createToolContext"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolRegistry", "definition": "(createToolRegistry, defineTool, createToolContext) => { const registry = createToolRegistry(); const tool = defineTool({ id: 'echo', description: 'Echo tool', parameters: { type: 'object', properties: { msg: { type: 'string' } }, required: ['msg'] }, execute: async (args) => ({ title: 'Echo', output: args.msg, metadata: {} }) }); registry.register(tool); if (!registry.has('echo')) throw new Error('Tool not registered'); if (registry.ids().length !== 1) throw new Error('Wrong ids count'); const anthro = registry.toAnthropicFormat(); if (anthro.length !== 1 || anthro[0].name !== 'echo') throw new Error('Anthropic format wrong'); return 'pass'; }", "inputs": ["createToolRegistry", "defineTool", "createToolContext"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "createTextPart", "definition": "(generateId) => (({ sessionId, messageId, text, synthetic = false }) => ({ id: generateId(), sessionId, messageId, type: 'text', text, synthetic, time: { start: Date.now(), end: null } }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createReasoningPart", "definition": "(generateId) => (({ sessionId, messageId, text }) => ({ id: generateId(), sessionId, messageId, type: 'reasoning', text, time: { start: Date.now(), end: null } }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStatePending", "definition": "() => ((input, raw = '') => ({ status: 'pending', input, raw }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateRunning", "definition": "() => ((input, title = null) => ({ status: 'running', input, title, metadata: {}, time: { start: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateCompleted", "definition": "() => (({ input, output, title, metadata = {}, startTime }) => ({ status: 'completed', input, output, title, metadata, time: { start: startTime, end: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "toolStateError", "definition": "() => (({ input, error, startTime }) => ({ status: 'error', input, error, metadata: {}, time: { start: startTime, end: Date.now() } }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolPart", "definition": "(generateId) => (({ sessionId, messageId, callId, tool, state }) => ({ id: generateId(), sessionId, messageId, type: 'tool', callId, tool, state, metadata: {} }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "anthropicProvider", "definition": "() => (({ apiKey, baseUrl = 'https://api.anthropic.com/v1', version = '2023-06-01' }) => ({ id: 'anthropic', baseUrl, headers: () => ({ 'x-api-key': apiKey, 'anthropic-version': version, 'anthropic-dangerous-direct-browser-access': 'true', 'Content-Type': 'application/json' }), messagesEndpoint: baseUrl + '/messages' }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "parseSSEStream", "definition": "() => (async (stream, onEvent, signal) => { const reader = stream.getReader(); const decoder = new TextDecoder(); let buffer = ''; try { while (true) { if (signal?.aborted) break; const { done, value } = await reader.read(); if (done) break; buffer += decoder.decode(value, { stream: true }); const lines = buffer.split('\\n'); buffer = lines.pop() || ''; for (const line of lines) { if (line.startsWith('data: ')) { const data = line.slice(6); if (data === '[DONE]') return; try { onEvent(JSON.parse(data)); } catch {} } } } } finally { reader.releaseLock(); } })", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "streamAnthropic", "definition": "(parseSSEStream) => (async ({ provider, model, messages, systemPrompt, tools, callbacks, signal, settings = {} }) => { const body = { model, messages, max_tokens: settings.max_tokens || 4096, stream: true, ...settings }; if (systemPrompt) body.system = systemPrompt; if (tools && tools.length > 0) body.tools = tools; const response = await fetch(provider.messagesEndpoint, { method: 'POST', headers: provider.headers(), body: JSON.stringify(body), signal }); if (!response.ok) { const error = await response.text(); callbacks.onError?.(new Error('Anthropic API error: ' + response.status + ' - ' + error)); throw new Error('Anthropic API error: ' + response.status); } let currentToolUse = null; let stopReason = null; let usage = null; await parseSSEStream(response.body, (event) => { if (event.type === 'message_start') usage = event.message?.usage; if (event.type === 'content_block_start') { const block = event.content_block; if (block?.type === 'tool_use') { currentToolUse = { id: block.id, name: block.name, input: '' }; callbacks.onToolCall?.(block.id, block.name); } } if (event.type === 'content_block_delta') { const delta = event.delta; if (delta?.type === 'text_delta') callbacks.onText?.(delta.text); else if (delta?.type === 'thinking_delta') callbacks.onReasoning?.(delta.thinking); else if (delta?.type === 'input_json_delta' && currentToolUse) { currentToolUse.input += delta.partial_json; callbacks.onToolCallDelta?.(currentToolUse.id, delta.partial_json); } } if (event.type === 'content_block_stop') currentToolUse = null; if (event.type === 'message_delta') { stopReason = event.delta?.stop_reason; if (event.usage) usage = { ...usage, ...event.usage }; } }, signal); callbacks.onFinish?.({ finishReason: stopReason, usage }); return { finishReason: stopReason, usage }; })", "inputs": ["parseSSEStream"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createTextPart", "definition": "(createTextPart) => { const part = createTextPart({ sessionId: 's1', messageId: 'm1', text: 'Hello' }); if (part.type !== 'text' || part.text !== 'Hello' || !part.id) throw new Error('Failed'); return 'pass'; }", "inputs": ["createTextPart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_toolStates", "definition": "(toolStatePending, toolStateRunning, toolStateCompleted, toolStateError) => { const p = toolStatePending({ foo: 'bar' }); if (p.status !== 'pending') throw new Error('Pending failed'); const r = toolStateRunning({ foo: 'bar' }, 'title'); if (r.status !== 'running' || r.title !== 'title') throw new Error('Running failed'); const c = toolStateCompleted({ input: {}, output: 'out', title: 't', startTime: Date.now() }); if (c.status !== 'completed') throw new Error('Completed failed'); const e = toolStateError({ input: {}, error: 'err', startTime: Date.now() }); if (e.status !== 'error') throw new Error('Error failed'); return 'pass'; }", "inputs": ["toolStatePending", "toolStateRunning", "toolStateCompleted", "toolStateError"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolPart", "definition": "(createToolPart, toolStatePending) => { const part = createToolPart({ sessionId: 's1', messageId: 'm1', callId: 'c1', tool: 'echo', state: toolStatePending({ msg: 'hi' }) }); if (part.type !== 'tool' || part.tool !== 'echo' || part.state.status !== 'pending') throw new Error('Failed'); return 'pass'; }", "inputs": ["createToolPart", "toolStatePending"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_anthropicProvider", "definition": "(anthropicProvider) => { const provider = anthropicProvider({ apiKey: 'test-key' }); if (provider.id !== 'anthropic') throw new Error('Wrong id'); if (!provider.messagesEndpoint.includes('anthropic.com')) throw new Error('Wrong endpoint'); const headers = provider.headers(); if (headers['x-api-key'] !== 'test-key') throw new Error('Wrong api key header'); return 'pass'; }", "inputs": ["anthropicProvider"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_parseSSEStream", "definition": "(parseSSEStream) => { const events = []; const mockStream = { getReader: () => { let done = false; return { read: async () => { if (done) return { done: true }; done = true; return { done: false, value: new TextEncoder().encode('data: {\"type\":\"test\"}\\n\\n') }; }, releaseLock: () => {} }; } }; return parseSSEStream(mockStream, (e) => events.push(e)).then(() => { if (events.length !== 1 || events[0].type !== 'test') throw new Error('Parse failed: ' + JSON.stringify(events)); return 'pass'; }); }", "inputs": ["parseSSEStream"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "completeAssistantMessage", "definition": "() => ((message, { finish, tokens, cost }) => ({ ...message, time: { ...message.time, completed: Date.now() }, finish, tokens: tokens || message.tokens, cost: cost ?? message.cost }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createStepStartPart", "definition": "(generateId) => (({ sessionId, messageId }) => ({ id: generateId(), sessionId, messageId, type: 'step-start' }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createStepFinishPart", "definition": "(generateId) => (({ sessionId, messageId, reason, tokens, cost }) => ({ id: generateId(), sessionId, messageId, type: 'step-finish', reason, cost, tokens }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createMessageWithParts", "definition": "() => ((info, parts = []) => ({ info, parts }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "addPart", "definition": "() => ((messageWithParts, part) => ({ ...messageWithParts, parts: [...messageWithParts.parts, part] }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "updatePart", "definition": "() => ((messageWithParts, partId, updates) => ({ ...messageWithParts, parts: messageWithParts.parts.map(p => p.id === partId ? { ...p, ...updates } : p) }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createConversation", "definition": "(generateId) => (({ id } = {}) => ({ id: id || generateId(), messages: [], created: Date.now() }))", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "addMessage", "definition": "() => ((conversation, messageWithParts) => ({ ...conversation, messages: [...conversation.messages, messageWithParts] }))", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "isToolPart", "definition": "() => (part => part?.type === 'tool')", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "updateToolPart", "definition": "(isToolPart) => ((message, callId, updates) => ({ ...message, parts: message.parts.map(p => isToolPart(p) && p.callId === callId ? { ...p, ...updates } : p) }))", "inputs": ["isToolPart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "conversationToMessages", "definition": "() => (conversation => conversation.messages.map(msg => { const role = msg.info.role; if (role === 'user') { const textParts = msg.parts.filter(p => p.type === 'text'); return { role: 'user', content: textParts.map(p => p.text).join('\\n') }; } else if (role === 'assistant') { return { role: 'assistant', parts: msg.parts }; } return { role, content: '' }; }))", "inputs": [], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "createLoop", "definition": "(anthropicProvider, streamAnthropic, createConversation, createUserMessage, createAssistantMessage, completeAssistantMessage, createTextPart, createReasoningPart, createToolPart, createStepStartPart, createStepFinishPart, createMessageWithParts, addPart, updatePart, addMessage, toolStatePending, toolStateRunning, toolStateCompleted, toolStateError, updateToolPart, conversationToMessages, createToolContext) => ((config) => { const { providerId, modelId, apiKey, systemPrompt, registry, maxSteps = 10, settings = {} } = config; const provider = anthropicProvider({ apiKey }); const tools = registry.toAnthropicFormat(); let conversation = createConversation(); let abortController = null; let isRunning = false; async function run(userPrompt, callbacks = {}) { if (isRunning) throw new Error('Loop is already running'); isRunning = true; abortController = new AbortController(); try { const userMessage = createUserMessage({ sessionId: conversation.id, agent: 'user', providerId, modelId, system: systemPrompt }); const userWithParts = createMessageWithParts(userMessage, [createTextPart({ sessionId: conversation.id, messageId: userMessage.id, text: userPrompt })]); conversation = addMessage(conversation, userWithParts); let step = 0; while (step < maxSteps) { if (abortController.signal.aborted) break; callbacks.onStepStart?.(step); const assistantMessage = createAssistantMessage({ sessionId: conversation.id, parentId: userMessage.id, agent: 'assistant', providerId, modelId }); let currentMessage = createMessageWithParts(assistantMessage, [createStepStartPart({ sessionId: conversation.id, messageId: assistantMessage.id })]); let currentText = ''; let currentTextPartId = null; const pendingToolCalls = new Map(); const result = await streamAnthropic({ provider, model: modelId, messages: conversationToMessages(conversation), systemPrompt, tools, signal: abortController.signal, settings, callbacks: { onText: (chunk) => { currentText += chunk; if (!currentTextPartId) { const textPart = createTextPart({ sessionId: conversation.id, messageId: assistantMessage.id, text: currentText }); currentTextPartId = textPart.id; currentMessage = addPart(currentMessage, textPart); } else { currentMessage = updatePart(currentMessage, currentTextPartId, { text: currentText }); } callbacks.onText?.(chunk); callbacks.onMessage?.(currentMessage); }, onToolCall: (callId, toolName) => { const toolPart = createToolPart({ sessionId: conversation.id, messageId: assistantMessage.id, callId, tool: toolName, state: toolStatePending({}, '') }); pendingToolCalls.set(callId, { toolName, args: '' }); currentMessage = addPart(currentMessage, toolPart); callbacks.onMessage?.(currentMessage); }, onToolCallDelta: (callId, chunk) => { const tc = pendingToolCalls.get(callId); if (tc) tc.args += chunk; }, onError: (error) => callbacks.onError?.(error) } }); let hasToolCalls = false; for (const [callId, tc] of pendingToolCalls) { hasToolCalls = true; let input = {}; try { input = JSON.parse(tc.args); } catch {} const startTime = Date.now(); currentMessage = updateToolPart(currentMessage, callId, { state: toolStateRunning(input, 'Running ' + tc.toolName) }); callbacks.onToolStart?.(callId, tc.toolName, input); const ctx = createToolContext({ sessionId: conversation.id, messageId: assistantMessage.id, agent: 'assistant', callId, abort: abortController.signal, runtime: typeof window !== 'undefined' ? window.__ojs_runtime : null }); const toolResult = await registry.execute(tc.toolName, input, ctx); if (toolResult.metadata?.error) { currentMessage = updateToolPart(currentMessage, callId, { state: toolStateError({ input, error: toolResult.output, startTime }) }); } else { currentMessage = updateToolPart(currentMessage, callId, { state: toolStateCompleted({ input, output: toolResult.output, title: toolResult.title, metadata: toolResult.metadata, startTime }) }); } callbacks.onToolFinish?.(callId, tc.toolName, toolResult); callbacks.onMessage?.(currentMessage); } const stepFinishPart = createStepFinishPart({ sessionId: conversation.id, messageId: assistantMessage.id, reason: result.finishReason || 'unknown', tokens: result.usage || { input: 0, output: 0, reasoning: 0, cache: { read: 0, write: 0 } }, cost: 0 }); currentMessage = addPart(currentMessage, stepFinishPart); currentMessage = { ...currentMessage, info: completeAssistantMessage(currentMessage.info, { finish: result.finishReason, tokens: result.usage, cost: 0 }) }; conversation = addMessage(conversation, currentMessage); callbacks.onStepFinish?.(step, currentMessage); const shouldContinue = hasToolCalls && result.finishReason !== 'end_turn'; if (!shouldContinue) break; step++; } callbacks.onFinish?.(conversation); return conversation; } finally { isRunning = false; abortController = null; } } function cancel() { if (abortController) abortController.abort(); } function getConversation() { return conversation; } function reset() { if (isRunning) throw new Error('Cannot reset while running'); conversation = createConversation(); } function running() { return isRunning; } return { run, cancel, getConversation, reset, running }; })", "inputs": ["anthropicProvider", "streamAnthropic", "createConversation", "createUserMessage", "createAssistantMessage", "completeAssistantMessage", "createTextPart", "createReasoningPart", "createToolPart", "createStepStartPart", "createStepFinishPart", "createMessageWithParts", "addPart", "updatePart", "addMessage", "toolStatePending", "toolStateRunning", "toolStateCompleted", "toolStateError", "updateToolPart", "conversationToMessages", "createToolContext"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "test_opencode_completeAssistantMessage", "definition": "(completeAssistantMessage) => { const msg = { time: { created: 1000 }, tokens: {}, cost: 0 }; const completed = completeAssistantMessage(msg, { finish: 'end_turn', tokens: { input: 10 }, cost: 0.01 }); if (!completed.time.completed || completed.finish !== 'end_turn') throw new Error('Failed'); return 'pass'; }", "inputs": ["completeAssistantMessage"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createMessageWithParts", "definition": "(createMessageWithParts, addPart, updatePart) => { const msg = createMessageWithParts({ id: 'm1', role: 'assistant' }, []); if (msg.parts.length !== 0) throw new Error('Initial parts not empty'); const withPart = addPart(msg, { id: 'p1', type: 'text', text: 'hello' }); if (withPart.parts.length !== 1) throw new Error('Part not added'); const updated = updatePart(withPart, 'p1', { text: 'updated' }); if (updated.parts[0].text !== 'updated') throw new Error('Update failed'); return 'pass'; }", "inputs": ["createMessageWithParts", "addPart", "updatePart"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createConversation", "definition": "(createConversation, addMessage, createMessageWithParts) => { const conv = createConversation(); if (!conv.id || conv.messages.length !== 0) throw new Error('Bad initial state'); const msg = createMessageWithParts({ id: 'm1', role: 'user' }, []); const updated = addMessage(conv, msg); if (updated.messages.length !== 1) throw new Error('Message not added'); return 'pass'; }", "inputs": ["createConversation", "addMessage", "createMessageWithParts"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createLoop", "definition": "(createLoop, createToolRegistry, defineTool) => { const registry = createToolRegistry(); registry.register(defineTool({ id: 'test', description: 'test', parameters: { type: 'object', properties: {} }, execute: async () => ({ title: 'Test', output: 'done', metadata: {} }) })); const loop = createLoop({ providerId: 'anthropic', modelId: 'claude-sonnet-4-20250514', apiKey: 'test-key', registry }); if (typeof loop.run !== 'function') throw new Error('run not a function'); if (typeof loop.cancel !== 'function') throw new Error('cancel not a function'); if (typeof loop.getConversation !== 'function') throw new Error('getConversation not a function'); return 'pass'; }", "inputs": ["createLoop", "createToolRegistry", "defineTool"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "readCellTool", "definition": "(defineTool) => defineTool({ id: 'read_cell', description: 'Read information about a notebook cell/variable including its current value and error state.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to read' } }, required: ['name'] }, execute: async (args, ctx) => { const { name } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Read cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let found = null; for (const v of runtime._variables) { if (v._name === name) { found = v; break; } } if (!found) return { title: 'Read cell: ' + name, output: 'Error: Cell not found: ' + name, metadata: { error: true, notFound: true } }; const serialize = (value, maxLen = 2000) => { if (value === undefined) return 'undefined'; if (value === null) return 'null'; if (value instanceof Error) return 'Error: ' + value.message; if (typeof value === 'function') return value.toString().slice(0, maxLen); if (typeof value === 'object') { try { return JSON.stringify(value, null, 2).slice(0, maxLen); } catch { return String(value); } } return String(value).slice(0, maxLen); }; const result = { name: found._name, hasValue: found._value !== undefined, hasError: found._error !== undefined, value: serialize(found._value), error: found._error?.message, reachable: found._reachable, inputs: found._inputs?.map(i => i._name).filter(Boolean) || [] }; return { title: 'Read cell: ' + name, output: JSON.stringify(result, null, 2), metadata: result }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "listCellsTool", "definition": "(defineTool) => defineTool({ id: 'list_cells', description: 'List all cells/variables in the notebook runtime with their names and states.', parameters: { type: 'object', properties: { filter: { type: 'string', description: 'Optional filter string to match cell names' }, module: { type: 'string', description: 'Optional module name to filter by' } }, required: [] }, execute: async (args, ctx) => { const { filter, module } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'List cells', output: 'Error: Observable runtime not found', metadata: { error: true } }; const moduleNames = new Map(); for (const v of runtime._variables) { if (v._module && !moduleNames.has(v._module)) { const modName = v._module._name || (v._name?.startsWith('module ') ? v._name : null); if (modName) moduleNames.set(v._module, modName); } } const variables = []; for (const v of runtime._variables) { if (!v._name) continue; const moduleName = moduleNames.get(v._module) || 'main'; if (filter && !v._name.includes(filter)) continue; if (module && moduleName !== module && !moduleName.includes(module)) continue; variables.push({ name: v._name, module: moduleName, hasValue: v._value !== undefined, hasError: v._error !== undefined, reachable: v._reachable }); } variables.sort((a, b) => { const modCmp = a.module.localeCompare(b.module); if (modCmp !== 0) return modCmp; return a.name.localeCompare(b.name); }); return { title: 'List cells (' + variables.length + ' found)', output: variables.map(v => v.module + '#' + v.name + ' [' + (v.hasValue ? 'value' : v.hasError ? 'error' : 'pending') + ']').join('\\n'), metadata: { count: variables.length, variables } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "defineCellTool", "definition": "(defineTool) => defineTool({ id: 'define_cell', description: 'Define or redefine a notebook cell/variable with new code.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to define' }, definition: { type: 'string', description: 'JavaScript function definition' }, inputs: { type: 'array', description: 'Array of input variable names' }, module: { type: 'string', description: 'Optional module name' } }, required: ['name', 'definition'] }, execute: async (args, ctx) => { const { name, definition, inputs = [], module: moduleName } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Define cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let targetModule = null; for (const v of runtime._variables) { if (v._module) { targetModule = v._module; break; } } if (!targetModule) return { title: 'Define cell: ' + name, output: 'Error: No module found', metadata: { error: true } }; let fn; try { eval('fn = ' + definition); } catch (e) { return { title: 'Define cell: ' + name, output: 'Error: ' + e.message, metadata: { error: true } }; } const newVar = targetModule.variable({}); newVar.define(name, inputs, fn); const actualRuntime = targetModule._runtime; if (actualRuntime?._computeNow) actualRuntime._computeNow(); return { title: 'Define cell: ' + name, output: 'Defined cell \"' + name + '\"', metadata: { name, inputs } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "deleteCellTool", "definition": "(defineTool) => defineTool({ id: 'delete_cell', description: 'Delete a cell/variable from the notebook runtime.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable to delete' } }, required: ['name'] }, execute: async (args, ctx) => { const { name } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Delete cell: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; for (const v of runtime._variables) { if (v._name === name) { v.delete(); return { title: 'Delete cell: ' + name, output: 'Deleted cell \"' + name + '\"', metadata: { name } }; } } return { title: 'Delete cell: ' + name, output: 'Error: Cell not found: ' + name, metadata: { error: true } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "getCellValueTool", "definition": "(defineTool) => defineTool({ id: 'get_cell_value', description: 'Get the computed value of a cell.', parameters: { type: 'object', properties: { name: { type: 'string', description: 'The name of the cell/variable' } }, required: ['name'] }, execute: async (args, ctx) => { const { name } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Get value: ' + name, output: 'Error: Observable runtime not found', metadata: { error: true } }; let found = null; for (const v of runtime._variables) { if (v._name === name) { found = v; break; } } if (!found) return { title: 'Get value: ' + name, output: 'Error: Cell not found: ' + name, metadata: { error: true } }; const serialize = (value, maxLen = 2000) => { if (value === undefined) return 'undefined'; if (value === null) return 'null'; if (typeof value === 'function') return value.toString().slice(0, maxLen); if (typeof value === 'object') { try { return JSON.stringify(value, null, 2).slice(0, maxLen); } catch { return String(value); } } return String(value).slice(0, maxLen); }; if (found._error) return { title: 'Get value: ' + name, output: 'Error: ' + found._error.message, metadata: { error: true } }; return { title: 'Get value: ' + name, output: serialize(found._value), metadata: {} }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "cellTools", "definition": "(readCellTool, listCellsTool, defineCellTool, deleteCellTool, getCellValueTool) => [readCellTool, listCellsTool, defineCellTool, deleteCellTool, getCellValueTool]", "inputs": ["readCellTool", "listCellsTool", "defineCellTool", "deleteCellTool", "getCellValueTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_cellTools", "definition": "(cellTools) => { if (!Array.isArray(cellTools) || cellTools.length !== 5) throw new Error('Wrong count: ' + cellTools.length); const ids = cellTools.map(t => t.id); if (!ids.includes('read_cell') || !ids.includes('list_cells') || !ids.includes('define_cell') || !ids.includes('delete_cell') || !ids.includes('get_cell_value')) throw new Error('Missing tool: ' + ids.join(', ')); return 'pass'; }", "inputs": ["cellTools"], "module": "@tomlarkworthy/tests"}

{"cmd": "define-variable", "name": "listModulesTool", "definition": "(defineTool) => defineTool({ id: 'list_modules', description: 'List all modules loaded in the notebook runtime.', parameters: { type: 'object', properties: {}, required: [] }, execute: async (args, ctx) => { const runtime = ctx.runtime; if (!runtime) return { title: 'List modules', output: 'Error: Observable runtime not found', metadata: { error: true } }; const modules = new Map(); for (const v of runtime._variables) { if (v._module && !modules.has(v._module)) { const modName = v._module._name || (v._name?.startsWith('module ') ? v._name.replace('module ', '') : null) || 'main'; modules.set(v._module, { name: modName, variables: 0 }); } if (v._module && v._name) { const mod = modules.get(v._module); if (mod) mod.variables++; } } const moduleList = [...modules.values()].sort((a, b) => a.name.localeCompare(b.name)); return { title: 'List modules (' + moduleList.length + ' found)', output: moduleList.map(m => m.name + ' (' + m.variables + ' variables)').join('\\n'), metadata: { count: moduleList.length, modules: moduleList } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "runTestsTool", "definition": "(defineTool) => defineTool({ id: 'run_tests', description: 'Run all test_* variables in the notebook and return results.', parameters: { type: 'object', properties: { filter: { type: 'string', description: 'Optional filter to match test names' } }, required: [] }, execute: async (args, ctx) => { const { filter } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Run tests', output: 'Error: Observable runtime not found', metadata: { error: true } }; const testVars = []; for (const v of runtime._variables) { if (typeof v._name === 'string' && v._name.startsWith('test_')) { if (filter && !v._name.includes(filter)) continue; testVars.push(v); } } if (testVars.length === 0) return { title: 'Run tests', output: filter ? 'No tests found matching \"' + filter + '\"' : 'No test_* variables found', metadata: { count: 0 } }; const results = testVars.map(v => ({ name: v._name, hasValue: v._value !== undefined, hasError: v._error !== undefined, value: v._value !== undefined ? String(v._value).slice(0, 100) : null, error: v._error?.message })); const passed = results.filter(r => r.hasValue && !r.hasError).length; const failed = results.filter(r => r.hasError).length; return { title: 'Run tests (' + passed + '/' + results.length + ' passed)', output: results.map(r => (r.hasError ? '✗ ' : '✓ ') + r.name + (r.error ? ': ' + r.error : '')).join('\\n'), metadata: { total: results.length, passed, failed, results } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "evalTool", "definition": "(defineTool) => defineTool({ id: 'eval', description: 'Evaluate JavaScript code in the notebook runtime context.', parameters: { type: 'object', properties: { code: { type: 'string', description: 'JavaScript code to evaluate' } }, required: ['code'] }, execute: async (args, ctx) => { const { code } = args; try { const result = eval(code); const serialize = (value, maxLen = 2000) => { if (value === undefined) return 'undefined'; if (value === null) return 'null'; if (value instanceof Error) return 'Error: ' + value.message; if (typeof value === 'function') return value.toString().slice(0, maxLen); if (typeof value === 'object') { try { return JSON.stringify(value, null, 2).slice(0, maxLen); } catch { return String(value); } } return String(value).slice(0, maxLen); }; return { title: 'Eval', output: serialize(result), metadata: { type: typeof result } }; } catch (e) { return { title: 'Eval', output: 'Error: ' + e.message, metadata: { error: true } }; } } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "searchCellsTool", "definition": "(defineTool) => defineTool({ id: 'search_cells', description: 'Search for cells containing specific text in their names or values.', parameters: { type: 'object', properties: { query: { type: 'string', description: 'Text to search for' }, limit: { type: 'number', description: 'Maximum number of results (default 20)' } }, required: ['query'] }, execute: async (args, ctx) => { const { query, limit = 20 } = args; const runtime = ctx.runtime; if (!runtime) return { title: 'Search: ' + query, output: 'Error: Observable runtime not found', metadata: { error: true } }; const queryLower = query.toLowerCase(); const matches = []; for (const v of runtime._variables) { if (!v._name) continue; let matchReason = null; if (v._name.toLowerCase().includes(queryLower)) matchReason = 'name'; if (!matchReason && v._definition && typeof v._definition === 'function') { const defStr = v._definition.toString(); if (defStr.toLowerCase().includes(queryLower)) matchReason = 'definition'; } if (!matchReason && typeof v._value === 'string' && v._value.toLowerCase().includes(queryLower)) matchReason = 'value'; if (matchReason) { matches.push({ name: v._name, matchReason, hasValue: v._value !== undefined, hasError: v._error !== undefined }); if (matches.length >= limit) break; } } return { title: 'Search: ' + query + ' (' + matches.length + ' found)', output: matches.map(m => m.name + ' [matched ' + m.matchReason + ']').join('\\n') || 'No matches found', metadata: { count: matches.length, matches } }; } })", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "runtimeTools", "definition": "(listModulesTool, runTestsTool, evalTool, searchCellsTool) => [listModulesTool, runTestsTool, evalTool, searchCellsTool]", "inputs": ["listModulesTool", "runTestsTool", "evalTool", "searchCellsTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "allTools", "definition": "(cellTools, runtimeTools) => [...cellTools, ...runtimeTools]", "inputs": ["cellTools", "runtimeTools"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_runtimeTools", "definition": "(runtimeTools) => { if (!Array.isArray(runtimeTools) || runtimeTools.length !== 4) throw new Error('Wrong count: ' + runtimeTools.length); const ids = runtimeTools.map(t => t.id); if (!ids.includes('list_modules') || !ids.includes('run_tests') || !ids.includes('eval') || !ids.includes('search_cells')) throw new Error('Missing tool: ' + ids.join(', ')); return 'pass'; }", "inputs": ["runtimeTools"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_allTools", "definition": "(allTools) => { if (!Array.isArray(allTools) || allTools.length !== 9) throw new Error('Wrong count: ' + allTools.length + ', expected 9 (5 cell + 4 runtime)'); return 'pass'; }", "inputs": ["allTools"], "module": "@tomlarkworthy/tests"}

{"cmd": "run-tests", "filter": "test_opencode", "timeout": 30000}
{"cmd": "quit"}
