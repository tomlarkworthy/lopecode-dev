{"cmd": "load", "notebook": "lopecode/lopebooks/notebooks/@tomlarkworthy_opencode-agent.html", "hash": "view=R100(S50(@tomlarkworthy/reactive-reflective-testing),S50(@tomlarkworthy/exporter-2))"}
{"cmd": "define-variable", "name": "validateParameters", "definition": "() => { const validate = (schema, value) => { const errors = []; if (schema.type === 'object') { if (typeof value !== 'object' || value === null) { errors.push('Expected object'); return { valid: false, errors }; } if (schema.required) { for (const field of schema.required) { if (!(field in value)) errors.push('Missing required field: ' + field); } } if (schema.properties) { for (const [key, propSchema] of Object.entries(schema.properties)) { if (key in value) { const r = validate(propSchema, value[key]); if (!r.valid) errors.push(...r.errors.map(e => key + ': ' + e)); } } } } else if (schema.type === 'string') { if (typeof value !== 'string') errors.push('Expected string, got ' + typeof value); } else if (schema.type === 'number' || schema.type === 'integer') { if (typeof value !== 'number') errors.push('Expected number, got ' + typeof value); } else if (schema.type === 'boolean') { if (typeof value !== 'boolean') errors.push('Expected boolean, got ' + typeof value); } else if (schema.type === 'array') { if (!Array.isArray(value)) errors.push('Expected array, got ' + typeof value); else if (schema.items) value.forEach((item, i) => { const r = validate(schema.items, item); if (!r.valid) errors.push(...r.errors.map(e => '[' + i + ']: ' + e)); }); } return { valid: errors.length === 0, errors }; }; return validate; }", "inputs": [], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "defineTool", "definition": "(generateId) => (({ id, description, parameters, execute }) => { if (!id || typeof id !== 'string') throw new Error('Tool must have a string id'); if (!description || typeof description !== 'string') throw new Error('Tool must have a string description'); if (!parameters || typeof parameters !== 'object') throw new Error('Tool must have a parameters object'); if (!execute || typeof execute !== 'function') throw new Error('Tool must have an execute function'); return { id, description, parameters, execute: async (args, ctx) => { try { if (ctx.abort?.aborted) return { title: id + ' aborted', output: 'Execution was aborted', metadata: { aborted: true } }; const result = await execute(args, ctx); return { title: result.title || id + ' completed', output: typeof result.output === 'string' ? result.output : JSON.stringify(result.output), metadata: { ...ctx.getMetadata?.() || {}, ...result.metadata } }; } catch (error) { return { title: id + ' failed', output: 'Error: ' + error.message, metadata: { error: true, errorMessage: error.message } }; } } }; })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolContext", "definition": "(generateId) => (({ sessionId, messageId, agent, callId, abort, runtime }) => { let currentMetadata = {}; return { sessionId, messageId, agent, callId: callId || generateId(), abort: abort || new AbortController().signal, runtime: runtime || (typeof window !== 'undefined' ? window.__ojs_runtime : null), metadata(update) { currentMetadata = { ...currentMetadata, ...update }; }, getMetadata() { return currentMetadata; } }; })", "inputs": ["generateId"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "createToolRegistry", "definition": "(validateParameters) => (() => { const tools = new Map(); return { register(tool) { if (tools.has(tool.id)) console.warn('Tool ' + tool.id + ' already registered, replacing'); tools.set(tool.id, tool); }, unregister(id) { return tools.delete(id); }, get(id) { return tools.get(id); }, has(id) { return tools.has(id); }, ids() { return [...tools.keys()]; }, all() { return [...tools.values()]; }, toAnthropicFormat() { return this.all().map(t => ({ name: t.id, description: t.description, input_schema: t.parameters })); }, async execute(id, args, ctx) { const tool = tools.get(id); if (!tool) return { title: 'Tool not found', output: 'Unknown tool: ' + id, metadata: { error: true } }; const validation = validateParameters(tool.parameters, args); if (!validation.valid) return { title: 'Invalid parameters', output: 'Parameter validation failed:\\n' + validation.errors.join('\\n'), metadata: { error: true, validationErrors: validation.errors } }; return tool.execute(args, ctx); } }; })", "inputs": ["validateParameters"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_validateParameters", "definition": "(validateParameters) => { const schema = { type: 'object', required: ['name'], properties: { name: { type: 'string' }, count: { type: 'number' } } }; const r1 = validateParameters(schema, { name: 'test', count: 5 }); if (!r1.valid) throw new Error('Valid input failed: ' + r1.errors.join(', ')); const r2 = validateParameters(schema, { count: 5 }); if (r2.valid || !r2.errors.includes('Missing required field: name')) throw new Error('Missing required not detected'); const r3 = validateParameters(schema, { name: 123 }); if (r3.valid || !r3.errors.some(e => e.includes('Expected string'))) throw new Error('Wrong type not detected'); return 'pass'; }", "inputs": ["validateParameters"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_defineTool", "definition": "(defineTool) => { const tool = defineTool({ id: 'test_tool', description: 'A test tool', parameters: { type: 'object', properties: {} }, execute: async (args) => ({ title: 'Test', output: 'result', metadata: {} }) }); if (tool.id !== 'test_tool') throw new Error('Wrong id'); if (typeof tool.execute !== 'function') throw new Error('Execute not a function'); return 'pass'; }", "inputs": ["defineTool"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolContext", "definition": "(createToolContext) => { const ctx = createToolContext({ sessionId: 's1', messageId: 'm1', agent: 'test' }); if (ctx.sessionId !== 's1') throw new Error('Wrong sessionId'); if (!ctx.callId) throw new Error('No callId'); ctx.metadata({ foo: 'bar' }); if (ctx.getMetadata().foo !== 'bar') throw new Error('Metadata not working'); return 'pass'; }", "inputs": ["createToolContext"], "module": "@tomlarkworthy/tests"}
{"cmd": "define-variable", "name": "test_opencode_createToolRegistry", "definition": "(createToolRegistry, defineTool, createToolContext) => { const registry = createToolRegistry(); const tool = defineTool({ id: 'echo', description: 'Echo tool', parameters: { type: 'object', properties: { msg: { type: 'string' } }, required: ['msg'] }, execute: async (args) => ({ title: 'Echo', output: args.msg, metadata: {} }) }); registry.register(tool); if (!registry.has('echo')) throw new Error('Tool not registered'); if (registry.ids().length !== 1) throw new Error('Wrong ids count'); const anthro = registry.toAnthropicFormat(); if (anthro.length !== 1 || anthro[0].name !== 'echo') throw new Error('Anthropic format wrong'); return 'pass'; }", "inputs": ["createToolRegistry", "defineTool", "createToolContext"], "module": "@tomlarkworthy/tests"}
{"cmd": "run-tests", "filter": "test_opencode", "timeout": 15000}
{"cmd": "quit"}
